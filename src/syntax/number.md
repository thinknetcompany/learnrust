# Integer

ในภาษา Rust การจัดการตัวเลขจำนวนเต็ม (Integer) มีการกำหนดประเภทที่ชัดเจนตามขนาดและชนิดของจำนวนเต็มที่ต้องการใช้ เช่น ขนาดของบิต (เช่น 8, 16, 32, 64, 128) และลักษณะการเก็บข้อมูล (Signed หรือ Unsigned)

- **Signed integers** (`i8`, `i16`, `i32`, `i64`, `i128`): ตัวเลขจำนวนเต็มที่สามารถเป็นค่าได้ทั้งบวกและลบ
- **Unsigned integers** (`u8`, `u16`, `u32`, `u64`, `u128`): ตัวเลขจำนวนเต็มที่ไม่เป็นค่าลบ

## ข้อจำกัด

เนื่องจาก **Signed integers** สามารถเก็บจำนวนลบได้ ทำให้ในกรณีที่จำนวนบิตเท่ากัน **Unsigned integers** จะสามารถเก็บจำนวนบวกได้มากกว่า

> [!NOTE]
> ตัวอย่าง **Integer** ขนาด 8 บิต
>
> - `i8` จะมีช่วงของค่าอยู่ที่ -2<sup>7</sup> จนถึง 2<sup>7</sup> - 1
> - `u8` จะมีช่วงของค่าอยู่ที่ 0 จนถึง 2<sup>8</sup> - 1

**ตัวอย่างการใช้งาน Integer**

```rust, editable
fn main() {
    let u_int:u8 = 255;
    let int:i8 = 127;
    println!("{} {}", u_int, int);
}
```

> ลองคิดดู
>
> - จะเกิดอะไรขึ้นถ้าเราทำให้ค่าของตัวแปรไม่อยู่ในช่วงของประเภทที่เราประกาศ?
> - `u32` มีช่วงของค่าที่เก็บได้เป็นเท่าไหร่?
> - `i32` มีช่วงของค่าที่เก็บได้เป็นเท่าไหร่?

# Float

ในภาษา Rust ตัวเลขทศนิยมถูกแบ่งออกเป็นประเภทที่ชัดเจน โดยมี 2 ประเภทหลัก:

- `f32`: ตัวเลขทศนิยมแบบ 32 บิต
- `f64`: ตัวเลขทศนิยมแบบ 64 บิต

การใช้ `f32` และ `f64` ขึ้นอยู่กับความต้องการในการจัดเก็บและความแม่นยำที่ต้องการในการคำนวณ โดยทั่วไปแล้ว `f64` จะถูกใช้เป็นค่าเริ่มต้นเนื่องจากมีความแม่นยำสูงกว่า

**ตัวอย่างการใช้งาน Float**

```rust, editable
fn main() {
    let f1:f32 = 1.0;
    let f2:f32 = 7.0;
    println!("{}", f1 / f2);
}
```

> ลองแก้โค้ดดู
>
> - ลองเปลี่ยนชนิดของ `f1` และ `f2` เป็น `f64` แล้วดูผลลัพธ์มีความแตกต่างจากเดิมหรือไม่
> - ลองเปลี่ยน `f1` และ `f2` เป็น `integer` แล้วสังเกตความแตกต่างที่เกิดขึ้น

# Type Conversion

ในการเขียนโปรแกรมด้วยภาษา Rust บางครั้งเราจำเป็นต้องแปลงค่าจากชนิดข้อมูลหนึ่งไปยังอีกชนิดหนึ่ง เช่น จาก `f64` ไปเป็น `i64` หรือจาก `u32` ไปเป็น `f64`

การแปลงชนิดข้อมูลสามารถทำได้โดยใช้คำสั่ง `as` ซึ่งเป็นตัวดำเนินการสำหรับการแปลงชนิดข้อมูลใน Rust

**ตัวอย่างการแปลงชนิดข้อมูล**

```rust, editable
fn main() {
    let float_num: f64 = 10.5;
    let int_num: i64 = float_num as i64;
    println!("{} convert to {}", float_num, int_num);
}
```

ในตัวอย่างนี้ เราแปลงค่าจาก `f64` ไปเป็น `i64` โดยใช้ `as i64` ซึ่งจะตัดส่วนทศนิยมออก

## การดำเนินการกับตัวเลขชนิดต่างกัน

ในการดำเนินการทางคณิตศาสตร์ เช่น การบวก ลบ คูณ หาร หรือการเปรียบเทียบ Rust จะไม่อนุญาตให้ดำเนินการกับตัวแปรที่มีชนิดข้อมูลต่างกัน เราต้องทำการแปลงชนิดข้อมูลให้ตรงกันก่อนจึงจะสามารถดำเนินการได้

**ตัวอย่างการดำเนินการกับตัวแปรชนิดต่างกัน**

```rust, editable
fn main() {
    let int_num: i32 = 10;
    let float_num: f32 = 5.5;
    let result = int_num as f32 + float_num;
    println!("sum : {}", result);
}
```

ในตัวอย่างนี้ หากเราพยายามบวก `int_num` กับ `float_num` โดยตรงจะเกิดข้อผิดพลาด เนื่องจากชนิดข้อมูลไม่ตรงกัน เราจึงต้องแปลง `int_num` เป็น `f32` ก่อนด้วย `as f32`

> [!NOTE]
> Rust เป็นภาษาที่มีความเข้มงวดในการจัดการชนิดข้อมูล เพื่อป้องกันข้อผิดพลาดที่อาจเกิดขึ้นจากการแปลงชนิดข้อมูลโดยไม่ได้ตั้งใจ

> ลองทำดู
>
> - ลองแปลง `float_num` เป็น `i32` แล้วสังเกตค่าที่ได้
> - ลองดำเนินการคูณระหว่าง `u8` และ `i8` โดยไม่แปลงชนิดข้อมูล แล้วดูว่ามีข้อผิดพลาดอะไรเกิดขึ้น?
> - ลองแปลง `i32` เป็น `u32` และลองใส่ค่าที่เป็นลบ ดูว่าเกิดอะไรขึ้น?
